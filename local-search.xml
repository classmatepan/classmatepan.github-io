<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>操作系统实战1-程序如何运行的</title>
    <link href="/2022/10/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2-%E7%AC%AC%E4%B8%80%E8%AE%B2/"/>
    <url>/2022/10/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2-%E7%AC%AC%E4%B8%80%E8%AE%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="程序如何运行起来的？"><a href="#程序如何运行起来的？" class="headerlink" title="程序如何运行起来的？"></a>程序如何运行起来的？</h1><p>参考：<a href="https://time.geekbang.org/article/369457?code=Wsnr97yd4YlBVh6-MIULynIv89rgEjd5QOG0Z1a9Jp0=">https://time.geekbang.org/article/369457?code=Wsnr97yd4YlBVh6-MIULynIv89rgEjd5QOG0Z1a9Jp0%3D</a> 和 CSAPP</p><h2 id="程序的编译过程"><a href="#程序的编译过程" class="headerlink" title="程序的编译过程"></a>程序的编译过程</h2><img src="https://phkblog-1307710240.cos.ap-beijing.myqcloud.com/image-20221027161442149.png" alt="编译四部曲" style="zoom:150%;"><ol><li><p><strong>预处理</strong>：预处理器（cpp）</p><p>​      将源程序进行预处理替换。例如#include XXX，就会将XXX文件内容替换到这个源程序中 #define  XXX进行宏替换 #ifndef 将不必要的代码进行过滤。<em>注意typedef不是简单替换</em>。</p></li><li><p><strong>编译</strong>：编译器（ccl）</p><p>​       将预处理的源文件（.i 文件）编译成汇编语言程序。.s<br>​       通过词法分析与语法分析，再确认所有指令符合语法规则后，将其<strong>翻译为等价的代码表达式汇编代码</strong>。</p></li><li><p><strong>汇编</strong>：汇编器（as）</p><p>​      汇编器将hello.s翻译成机器指令，将指令打包成一种”可重定位的目标程序，并将结果保存在目标文件中“目标文件分成两段：<br>​       代码段：程序指令，可读、可执行、不可写<br>​       数据段：放程序的全局变量或者静态变量</p></li><li><p><strong>链接</strong>：链接器（ld）</p><p>​       将有关的<strong>目标文件</strong>彼此链接，也将在一个<strong>文件中引用的符号</strong>同<strong>该符号</strong>在<strong>另一个文件</strong>中定义<strong>链接在一起</strong>，使得所有这些目标文件成为一个<strong>可以装入操作系统</strong>的<strong>统一整体</strong>。</p><p>​       结果就得到 hello 文件，它是一个可执行目标文件（或者简称为可执行文件），可以被加载到内存中，由系统执行。</p></li></ol><img src="https://phkblog-1307710240.cos.ap-beijing.myqcloud.com/image-20221030161348684.png" alt="编译流程" style="zoom:67%;"><h2 id="程序装载执行"><a href="#程序装载执行" class="headerlink" title="程序装载执行"></a>程序装载执行</h2><h3 id="图灵机"><a href="#图灵机" class="headerlink" title="图灵机"></a>图灵机</h3><p>图灵机是一个抽象的模型，它是这样的：有一条<strong>无限长</strong>的纸带，纸带上有无限个小格子，小格子中写有相关的信息，纸带上有一个<strong>读头</strong>，读头能根据纸带小格子里的信息做相关的操作并能<strong>来回移动</strong>。</p><img src="https://phkblog-1307710240.cos.ap-beijing.myqcloud.com/image-20221030161543221.png" alt="图灵机模型" style="zoom:150%;"><h3 id="冯诺依曼体系结构"><a href="#冯诺依曼体系结构" class="headerlink" title="冯诺依曼体系结构"></a>冯诺依曼体系结构</h3><p><strong>电子计算机使用二进制数制系统和储存程序，并按照程序顺序执行。</strong>冯诺依曼体系结构的核心</p><p>根据冯诺依曼体系结构构成的计算机，必须具有如下功能以及组件：</p><table><thead><tr><th>功能</th><th>组件</th></tr></thead><tbody><tr><td>把程序和数据装入到计算机中</td><td>装载数据和程序的输入设备</td></tr><tr><td>必须具有长期记住程序、数据的中间结果及最终运算结果</td><td>记住程序和数据的存储器</td></tr><tr><td>完成各种算术、逻辑运算和数据传送等数据加工处理</td><td>完成数据加工处理的运算器</td></tr><tr><td>根据需要控制程序走向，并能根据指令控制机器的各部件协调操作</td><td>控制程序执行的控制器</td></tr><tr><td>能够按照要求将处理的数据结果显示给用户</td><td>显示处理结果的输出设备。</td></tr></tbody></table><h2 id="HelloWord程序装入原型计算机"><a href="#HelloWord程序装入原型计算机" class="headerlink" title="HelloWord程序装入原型计算机"></a>HelloWord程序装入原型计算机</h2><p>对hello进行反编译操作，使用odjump操作，以下main部分函数代码</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">000000000000063a</span> &lt;main&gt;:<br>  <span class="hljs-attribute">1</span>列         <span class="hljs-number">2</span>列                            <span class="hljs-number">3</span>列                            <span class="hljs-number">4</span>列<br> <span class="hljs-attribute">63a</span>:<span class="hljs-number">55</span>                   push   %rbp<br> <span class="hljs-attribute">63b</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> e5             mov    %rsp,%rbp<br> <span class="hljs-attribute">63e</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">10</span>          sub    $<span class="hljs-number">0</span>x10,%rsp<br> <span class="hljs-attribute">642</span>:<span class="hljs-number">89</span> <span class="hljs-number">7</span>d fc             mov    %edi,-<span class="hljs-number">0</span>x4(%rbp)<br> <span class="hljs-attribute">645</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">75</span> f0          mov    %rsi,-<span class="hljs-number">0</span>x10(%rbp)<br> <span class="hljs-attribute">649</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">3</span>d <span class="hljs-number">94</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> lea    <span class="hljs-number">0</span>x94(%rip),%rdi        # <span class="hljs-number">6</span>e4 &lt;_IO_stdin_used+<span class="hljs-number">0</span>x4&gt;<br> <span class="hljs-attribute">650</span>:e8 bb fe ff ff       callq  <span class="hljs-number">510</span> &lt;puts@plt&gt;<br> <span class="hljs-attribute">655</span>:b8 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x0,%eax<br> <span class="hljs-attribute">65a</span>:c9                   leaveq <br> <span class="hljs-attribute">65b</span>:c3                   retq   <br> <span class="hljs-attribute">65c</span>:<span class="hljs-number">0</span>f <span class="hljs-number">1</span>f <span class="hljs-number">40</span> <span class="hljs-number">00</span>          nopl   <span class="hljs-number">0</span>x0(%rax)<br></code></pre></td></tr></table></figure><p>分成四列：第一列为<strong>地址</strong>；第二列为十六进制，表示<strong>真正装入机器中的代码数据</strong>；第三列是对应的汇编代码；第四列是相关代码的注释。这是 x86_64 体系的代码，由此可以看出 x86 CPU 是变长指令集。</p><img src="https://phkblog-1307710240.cos.ap-beijing.myqcloud.com/image-20221030162808811.png" alt="helloworld文件加载到冯诺依曼模型" style="zoom:150%;"><p>CPU在图灵机纸带上操作</p><h2 id="思考：call-和-ret-指令在逻辑上执行的操作？"><a href="#思考：call-和-ret-指令在逻辑上执行的操作？" class="headerlink" title="思考：call 和 ret 指令在逻辑上执行的操作？"></a>思考：call 和 ret 指令在逻辑上执行的操作？</h2><p>为了实现 C 语言中函数的调用和返回功能，CPU 实现了函数调用和返回指令，即上图汇编代码中的“call”，“ret”指令，请你思考一下：call 和 ret 指令在逻辑上执行的操作是怎样的呢？</p><p> 首先假设CPU执行指令是顺序执行的，那么程序的调用需要考虑几个问题: </p><p>1，call指令要执行的代码在哪？也就是被调用函数的第一条指令所在的内存地址 </p><p>2，被调用函数执行完之后，返回哪个位置继续执行？ </p><p>只要解决<strong>上面这两个问题</strong>，那么函数调用时指令的间的跳转就迎刃而解了。 </p><p>针对第一个问题，在gcc编译完成之后，<strong>函数对应的指令序列所在的位置就已经确定了</strong>，因此这是编译阶段需要考虑的问题 </p><p>至于第二个问题，<strong>在执行完call指令的同时</strong>，需要将call指令下面一条<strong>指令的地址保存到栈内存中</strong>，同时更新%rsp寄存器指向的位置，然后就可以开始执行被调函数的指令序列，执行完毕后，<strong>由ret指令从rsp中获取栈顶的returnadress地址</strong>，然后跳转到call的下一条指令继续执行。</p>]]></content>
    
    
    
    <tags>
      
      <tag>图灵 冯诺依曼</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣每日一题</title>
    <link href="/2022/10/27/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    <url>/2022/10/27/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="2022-10-27-数组元素积的符号"><a href="#2022-10-27-数组元素积的符号" class="headerlink" title="2022-10-27 数组元素积的符号"></a><a href="https://leetcode.cn/problems/sign-of-the-product-of-an-array/">2022-10-27 数组元素积的符号</a></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">arraySign</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-comment">// 记录负数的个数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;num : nums)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">// 检测到了0，直接返回0</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            ++res;<span class="hljs-comment">// 检测到了负数+1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;<span class="hljs-comment">// 负数是偶数则1，反之为-1</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2022-10-28-子数组的最小值之和"><a href="#2022-10-28-子数组的最小值之和" class="headerlink" title="2022-10-28 子数组的最小值之和"></a><a href="https://leetcode.cn/problems/sum-of-subarray-minimums/">2022-10-28 子数组的最小值之和</a></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//方法1 动态规划</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumSubarrayMins</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 数组的长度</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;     <span class="hljs-comment">// dp[i] 以下标i结尾的所有的子数组的最小值之和</span><br>    dp[<span class="hljs-number">0</span>] = arr[<span class="hljs-number">0</span>];           <span class="hljs-comment">// 第一个以自己为结尾</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &gt;= <span class="hljs-number">0</span>; --j)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &lt; arr[i]) <span class="hljs-comment">// 遇到了一个比我当前还要小的数字下标</span><br>            &#123;<br>                dp[i] += dp[j]; <span class="hljs-comment">// 将当前的下标记录下来</span><br>                dp[i] %= MOD;<br>                <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 这时候没有必要再去遍历后面的内容</span><br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">// 大于等于的算是当前的加上s</span><br>                dp[i] += arr[i];<br>                dp[i] %= MOD;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">accumulate</span>(dp.<span class="hljs-built_in">begin</span>(), dp.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://phkblog-1307710240.cos.ap-beijing.myqcloud.com/image-20221028150439834.png" alt="单调栈方法的样例示意" style="zoom:150%;"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">// 动态规划 + 单调栈</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumSubarrayMins</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 数组的长度</span><br>    stack&lt;<span class="hljs-type">int</span>&gt; help_index;    <span class="hljs-comment">// 单调栈</span><br>    help_index.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>    dp[<span class="hljs-number">0</span>] = arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> res = dp[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (!help_index.<span class="hljs-built_in">empty</span>() &amp;&amp; arr[i] &lt; arr[help_index.<span class="hljs-built_in">top</span>()])<br>        &#123;<br>            <span class="hljs-comment">// help_index不是空的，当前位置小于stack前面的这个</span><br>            help_index.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (help_index.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-comment">// 遇到了最小的，以当前位为结尾的最小</span><br>            dp[i] = (i + <span class="hljs-number">1</span>) * arr[i] % MOD;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">// 单调栈内部还有东西，说明当前的不是最小</span><br>            dp[i] = ((i - help_index.<span class="hljs-built_in">top</span>()) * arr[i] + dp[help_index.<span class="hljs-built_in">top</span>()]) % MOD;<br>        &#125;<br>        res = (res + dp[i]) % MOD;<br>        help_index.<span class="hljs-built_in">emplace</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2022-10-29-统计匹配检索规则的物品数量"><a href="#2022-10-29-统计匹配检索规则的物品数量" class="headerlink" title="2022-10-29 统计匹配检索规则的物品数量"></a><a href="https://leetcode.cn/problems/count-items-matching-a-rule/">2022-10-29 统计匹配检索规则的物品数量</a></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Cpp"><span class="hljs-comment">// 遍历 简单题</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countMatches</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt;&amp; items, string ruleKey, string ruleValue)</span> </span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-comment">// 累计个数</span><br>    <span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;<span class="hljs-comment">// 标志位，以哪一个为中心</span><br>    <span class="hljs-keyword">if</span> (ruleKey == <span class="hljs-string">&quot;color&quot;</span>) &#123;<br>        flag = <span class="hljs-number">1</span>;<span class="hljs-comment">//颜色则为1</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ruleKey == <span class="hljs-string">&quot;name&quot;</span>) &#123;<br>        flag = <span class="hljs-number">2</span>;<span class="hljs-comment">//名字则为2</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> <span class="hljs-type">const</span> &amp;vec:items) &#123;<br>        <span class="hljs-keyword">if</span> (ruleValue == vec[flag]) res++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2022-10-30-字母大小写全排列"><a href="#2022-10-30-字母大小写全排列" class="headerlink" title="2022-10-30 字母大小写全排列"></a><a href="https://leetcode.cn/problems/letter-case-permutation/">2022-10-30 字母大小写全排列</a></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs Cpp">vector&lt;string&gt; res; <span class="hljs-comment">// 存储结果</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string &amp;cur, string &amp;source, <span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 递归终止条件</span><br>    <span class="hljs-keyword">if</span> (cur.<span class="hljs-built_in">size</span>() == source.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        res.<span class="hljs-built_in">push_back</span>(cur);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 遇到数字直接加进去然后进行后续</span><br>    <span class="hljs-keyword">if</span> (source[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; source[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)<br>    &#123;<br>        cur.<span class="hljs-built_in">push_back</span>(source[i]);<br>        <span class="hljs-built_in">dfs</span>(cur, source, i + <span class="hljs-number">1</span>);<br>        cur.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">// 先将原来的情况进行一次dfs</span><br>        <span class="hljs-type">char</span> next = source[i];<br>        cur.<span class="hljs-built_in">push_back</span>(next);<br>        <span class="hljs-built_in">dfs</span>(cur, source, i + <span class="hljs-number">1</span>);<br>        cur.<span class="hljs-built_in">pop_back</span>();<br>        <span class="hljs-comment">// 进行反转后之后，再进行一次dfs</span><br>        <span class="hljs-keyword">if</span> (next &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; next &lt;= <span class="hljs-string">&#x27;z&#x27;</span>)<br>        &#123;<br>            next = <span class="hljs-string">&#x27;A&#x27;</span> + next - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            next = <span class="hljs-string">&#x27;a&#x27;</span> + next - <span class="hljs-string">&#x27;A&#x27;</span>;<br>        &#125;<br>        cur.<span class="hljs-built_in">push_back</span>(next);<br>        <span class="hljs-built_in">dfs</span>(cur, source, i + <span class="hljs-number">1</span>);<br>        cur.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">letterCasePermutation</span><span class="hljs-params">(string s)</span></span><br><span class="hljs-function"></span>&#123;<br>    std::string c;<br>    <span class="hljs-built_in">dfs</span>(c, s, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>每天一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP第一章 计算机系统漫游</title>
    <link href="/2022/10/27/CSAPP%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/"/>
    <url>/2022/10/27/CSAPP%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-1-信息就是-位-上下文"><a href="#1-1-信息就是-位-上下文" class="headerlink" title="1.1 信息就是 位 + 上下文"></a>1.1 信息就是 位 + 上下文</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// ---hello.c---</span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>hello.c 程序是以字节序列的方式储存在文件中的（<em>这种方式实际上就是用一个唯一的单字节大小的✦整数值✦来表示每个字符）</em>，每个字节都有一个整数值，对应于某些字符。</p><p>像hello.c这种只是由ASCII字符构成的文件称为 <strong>文本文件</strong></p><p>其他的都是 <strong>二进制文件</strong></p><p>基本思想：<strong>系统中所有的信息</strong>——包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由<strong>一串比特表示的</strong>。<strong>区分</strong>不同数据对象的<strong>唯一方法</strong>是我们读到这些数据对象时的<strong>上下文</strong>。</p><h1 id="1-2-程序被其他程序翻译成不同的格式"><a href="#1-2-程序被其他程序翻译成不同的格式" class="headerlink" title="1.2 程序被其他程序翻译成不同的格式"></a>1.2 程序被其他程序翻译成不同的格式</h1><img src="https://phkblog-1307710240.cos.ap-beijing.myqcloud.com/image-20221027161442149.png" alt="编译四部曲" style="zoom:150%;"><ol><li><p><strong>预处理</strong>：预处理器（cpp）</p><p>​      将源程序进行预处理替换。例如#include XXX，就会将XXX文件内容替换到这个源程序中 #define  XXX进行宏替换 #ifndef 将不必要的代码进行过滤。<em>注意typedef不是简单替换</em>。</p></li><li><p><strong>编译</strong>：编译器（ccl）</p><p>​       将预处理的源文件（.i 文件）编译成汇编语言程序。.s<br>​       通过词法分析与语法分析，再确认所有指令符合语法规则后，将其<strong>翻译为等价的代码表达式汇编代码</strong>。</p></li><li><p><strong>汇编</strong>：汇编器（as）</p><p>​      汇编器将hello.s翻译成机器指令，将指令打包成一种”可重定位的目标程序，并将结果保存在目标文件中“目标文件分成两段：<br>​       代码段：程序指令，可读、可执行、不可写<br>​       数据段：放程序的全局变量或者静态变量</p></li><li><p><strong>链接</strong>：链接器（ld）</p><p>​       将有关的<strong>目标文件</strong>彼此链接，也将在一个<strong>文件中引用的符号</strong>同<strong>该符号</strong>在<strong>另一个文件</strong>中定义<strong>链接在一起</strong>，使得所有这些目标文件成为一个<strong>可以装入操作系统</strong>的<strong>统一整体</strong>。</p><p>​       结果就得到 hello 文件，它是一个可执行目标文件（或者简称为可执行文件），可以被加载到内存中，由系统执行。</p></li></ol><h1 id="1-4-处理器-读并解释-存储在内存中的指令"><a href="#1-4-处理器-读并解释-存储在内存中的指令" class="headerlink" title="1.4 处理器 读并解释 存储在内存中的指令"></a>1.4 处理器 读并解释 存储在内存中的指令</h1><h2 id="1-4-1系统的硬件组成"><a href="#1-4-1系统的硬件组成" class="headerlink" title="1.4.1系统的硬件组成"></a>1.4.1系统的硬件组成</h2><blockquote><p>经典的系统硬件四个部分</p><p>CPU：中央处理单元；ALU：算术&#x2F;逻辑单元；PC：程序计数器；USB：通用串行总线</p></blockquote><img src="https://phkblog-1307710240.cos.ap-beijing.myqcloud.com/image-20221029191328109.png" alt="intel系统产品族的模型" style="zoom:80%;"><h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><p>通常总线被设计成传送定长的字节块，也就是<strong>字（word）</strong>。字中的字节数（即字长）是一个基本的系统参数，各个系统中都不尽相同。现在的大多数机器字长要么是 4 个字节（32 位），要么是 8 个字节（64 位）。</p><h3 id="I-x2F-O设备"><a href="#I-x2F-O设备" class="headerlink" title="I&#x2F;O设备"></a>I&#x2F;O设备</h3><p>最初可执行程序是放在磁盘中。<br>每个 I&#x2F;O 设备都通过一个<strong>控制器</strong>或<strong>适配器</strong>与 I&#x2F;O 总线相连。控制器和适配器之间的<strong>区别</strong>主要在于它们的封装方式。控制器是 I&#x2F;O 设备本身或者系统的主印制电路板（通常称作主板）上的<strong>芯片组</strong>。而适配器则是一块<strong>插在主板插槽上的卡</strong>。无论如何，它们的功能都是在 I&#x2F;O 总线和 I&#x2F;O 设备之间传递信息。</p><h3 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h3><p>主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组<strong>动态随机存取存储器</strong>（DRAM）芯片组成的。</p><p>从逻辑上看：主存就是一个线性字节数组，每个字节都有唯一的地址（类似数组的索引），这些地址是从0开始的。<br>一般来说，组成程序的每条机器指令都是由不同数量的字节构成。</p><h3 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h3><p>CPU是解释（或执行）存储在主存中指令的引擎。<br>处理器的核心是一个大小为<strong>一个字</strong>的存储设备（或<strong>寄存器</strong>），称为<strong>程序计数器</strong>（PC）。<br>在任何时刻，PC 都指向主存中的<strong>某条机器语言指令</strong>（即含有该条指令的地址）。</p><p>从系统通电开始，直到系统断电，处理器一直<strong>执行</strong>程序计数器指向的指令，然后再<strong>更新</strong>程序计数器，使其指向下一条指令。</p><h2 id="1-4-2-运行hello程序"><a href="#1-4-2-运行hello程序" class="headerlink" title="1.4.2 运行hello程序"></a>1.4.2 运行hello程序</h2><ol><li><p>shell程序执行指令，等我们输入一个命令。当我们在键盘上输入字符串“.&#x2F;hello”，<strong>shell程序将字符逐一读入寄存器中，再把它放到内存中</strong>。遇到回车，结束命令输入。</p><img src="https://phkblog-1307710240.cos.ap-beijing.myqcloud.com/image-20221030185001352.png" alt="键盘输入指令./hello指令" style="zoom: 80%;"></li><li><p>shell开始<strong>执行指令</strong>来<strong>加载可执行hello文件</strong>，并且这些指令将<strong>hello目标文件中的代码和数据</strong>从磁盘复制到主存。其中数据包括最终会被输出的字符串“hello world\n”</p></li><li><p>利用DMA技术，数据可以不通过处理器而直接从磁盘到达主存中。</p><img src="https://phkblog-1307710240.cos.ap-beijing.myqcloud.com/image-20221030185054412.png" alt="DMA技术" style="zoom: 80%;"></li><li><p>目标文件hello中的<strong>代码和数据</strong>被加载到主存，处理器就开始执行hello程序的main程序中的机器语言指令。这些指令将“hello world\n”字符串中的字节从<strong>内存复制到寄存器文件</strong>，再从<strong>寄存器文件中复制到显示设备</strong>。<img src="https://phkblog-1307710240.cos.ap-beijing.myqcloud.com/image-20221030185121930.png" alt="运行hello程序显示结果" style="zoom:50%;"></p></li></ol><h1 id="1-5-高速缓存至关重要"><a href="#1-5-高速缓存至关重要" class="headerlink" title="1.5 高速缓存至关重要"></a>1.5 高速缓存至关重要</h1><h2 id="1-5-1-CPU运行速度很快，磁盘读写很慢，如何解决速度差"><a href="#1-5-1-CPU运行速度很快，磁盘读写很慢，如何解决速度差" class="headerlink" title="1.5.1 CPU运行速度很快，磁盘读写很慢，如何解决速度差"></a>1.5.1 CPU运行速度很快，磁盘读写很慢，如何解决速度差</h2><p>​       针对这种处理器与主存之间的差异，系统设计者采用了更小更快的存储设备，称为<strong>高速缓存存储器</strong>（cache memory，简称为 cache 或高速缓存），作为暂时的集结区域，存放处理器近期可能会需要的信息。<br>​        比较新的、处理能力更强大的系统甚至有三级高速缓存∶L1、L2 和 L3。系统可以获得一个很大的存储器，同时访问速度也很快，原因是利用了<strong>高速缓存的局部性原理</strong>：即程序具有访问局部区域里的数据和代码的趋势。通过让高速缓存里存放可能经常访问的数据，大部分的内存操作都能在快速的高速缓存中完成。</p><h1 id="1-6-存储设备形成层次结构"><a href="#1-6-存储设备形成层次结构" class="headerlink" title="1.6 存储设备形成层次结构"></a>1.6 存储设备形成层次结构</h1><img src="https://phkblog-1307710240.cos.ap-beijing.myqcloud.com/image-20221030191316798.png" alt="存储器层次结构示例" style="zoom:80%;"><p>经典图例，多级缓存来提高计算机的运行速度</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机系统概述 编辑器实现过程调用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP笔记</title>
    <link href="/2022/10/27/CSAPP%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/10/27/CSAPP%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id><a href="#" class="headerlink" title></a></h1><h2 id="第一章-计算机系统漫游"><a href="#第一章-计算机系统漫游" class="headerlink" title="第一章 计算机系统漫游"></a>第一章 计算机系统漫游</h2><h1 id="第二部分-程序结构和执行"><a href="#第二部分-程序结构和执行" class="headerlink" title="第二部分 程序结构和执行"></a>第二部分 程序结构和执行</h1><h2 id="第二章-信息的表示和处理"><a href="#第二章-信息的表示和处理" class="headerlink" title="第二章 信息的表示和处理"></a>第二章 信息的表示和处理</h2><h2 id="第三章-程序的机器级表示"><a href="#第三章-程序的机器级表示" class="headerlink" title="第三章 程序的机器级表示"></a>第三章 程序的机器级表示</h2><h2 id="第四章-处理器体系结构"><a href="#第四章-处理器体系结构" class="headerlink" title="第四章 处理器体系结构"></a>第四章 处理器体系结构</h2><h2 id="第五章-优化程序性能"><a href="#第五章-优化程序性能" class="headerlink" title="第五章 优化程序性能"></a>第五章 优化程序性能</h2><h2 id="第六章-存储器层级结构"><a href="#第六章-存储器层级结构" class="headerlink" title="第六章 存储器层级结构"></a>第六章 存储器层级结构</h2>]]></content>
    
    
    
    <tags>
      
      <tag>CSAPP笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络---小林Coding---TCP篇</title>
    <link href="/2022/10/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%B0%8F%E6%9E%97Coding/"/>
    <url>/2022/10/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%B0%8F%E6%9E%97Coding/</url>
    
    <content type="html"><![CDATA[<p>本文主要是在学习<a href="https://xiaolincoding.com/%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%81%9A%E7%9A%84%E7%AC%94%E8%AE%B0">https://xiaolincoding.com/过程中做的笔记</a><br>膜拜小林coding大神！</p><h1 id="TCP基础"><a href="#TCP基础" class="headerlink" title="TCP基础"></a>TCP基础</h1><h2 id="TCP头部格式"><a href="#TCP头部格式" class="headerlink" title="TCP头部格式"></a>TCP头部格式</h2><img src="https://phkblog-1307710240.cos.ap-beijing.myqcloud.com/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzYuanBn" alt="TCP 头格式" style="zoom: 50%;"><p><strong>序列号</strong>：在建立连接时，由计算机生成的随机数作为初始值，通过SYN包传送给接收端主机，没发送一次数据，就会“累加”一次该”数据字节数”的大小。主要用来解决网络包乱序的问题。</p><p><strong>确认应答号</strong>：指下一次*”期望”<em>收到数据的序列号，发送端收到这个确认应答之后就可以认为在这个序列号以前的数据都已经被正常的接受。主要用来解决</em>丢包*问题。</p><p><strong>控制位</strong>：</p><ul><li><em>ACK</em>：该位为 <code>1</code> 时，确认应答 的字段变为有效，TCP 规定<em><strong>除了</strong>最初建立连接时的 <code>SYN</code> 包之外（第一次握手）</em>该位必须设置为 <code>1</code> 。</li><li><em>RST</em>：该位为 <code>1</code> 时，表示 TCP 连接中<strong>出现异常</strong>必须<strong>强制断开连接</strong>。</li><li><em>SYN</em>：该位为 <code>1</code> 时，表示希望建立连接，并在其 序列号 的字段进行序列号初始值的设定。</li><li><em>FIN</em>：该位为 <code>1</code> 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 <code>FIN</code> 位为 1 的 TCP 段。</li></ul><h2 id="为什么需要TCP协议？"><a href="#为什么需要TCP协议？" class="headerlink" title="为什么需要TCP协议？"></a>为什么需要TCP协议？</h2><p>IP 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。</p><p>如果需要保障网络数据包的可靠性，那么就需要由上层（传输层）的 <code>TCP</code> 协议来负责。</p><p>因为 TCP 是一个工作在<strong>传输层</strong>的<strong>可靠</strong>数据传输的服务，它能确保接收端接收的网络包是  无损坏、无间隔、非冗余和按序的。</p><h2 id="什么是TCP协议？"><a href="#什么是TCP协议？" class="headerlink" title="什么是TCP协议？"></a>什么是TCP协议？</h2><p>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。</p><p>面向连接：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</p><p><a href="#TCP%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E5%8F%AF%E9%9D%A0%E6%80%A7%EF%BC%9F">可靠性</a>：无论的<strong>网络链路中</strong>出现了怎样的链路变化，TCP都可以<strong>保证一个报文一定能够到达接收端</strong>；</p><p>字节流：用户消息通过 TCP 协议传输时，<strong>消息可能会被操作系统「分组」成多个的 TCP 报文</strong>，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。</p><h2 id="TCP如何做到可靠性？"><a href="#TCP如何做到可靠性？" class="headerlink" title="TCP如何做到可靠性？"></a>TCP如何做到可靠性？</h2><p><strong>粗略</strong>：</p><p>因为TCP在<strong>数据传输之前会有三次握手</strong>来进行连接<br>在数据传输时候，有确认、滑动窗口、超时重传、拥塞控制之类机制<br>数据传输之后会进行四次挥手断开连接来节约系统资源。</p><p><strong>具体：</strong></p><p>1、应用数据被分割成TCP认为最适合发送的数据块<br>2、TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。<br>3、校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。<br>4、TCP 的接收端会丢弃重复的数据。<br>5、利用滑动窗口实现流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）<br>6、拥塞控制： 当网络拥塞时，减少数据的发送。<br>7、ARQ协议： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。<br>8、超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络 小林Coding</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>操作系统实战2-实现一个最简单的内核</title>
    <link href="/2022/10/31/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2-%E7%AC%AC%E4%BA%8C%E8%AE%B2/"/>
    <url>/2022/10/31/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2-%E7%AC%AC%E4%BA%8C%E8%AE%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="Hello-Os引导流程"><a href="#Hello-Os引导流程" class="headerlink" title="Hello Os引导流程"></a>Hello Os引导流程</h2><img src="https://phkblog-1307710240.cos.ap-beijing.myqcloud.com/image-20221031152405319.png" alt="Hello OS引导流程图" style="zoom:80%;" /><p>PC机BIOS固件是固化在PC机主板上的<strong>ROM芯片</strong>中，掉电也是可以保护的，PC机上电之后<strong>第一条指令</strong>就是BIOS固件中的，它负责<strong>检测和初始化CPU、内存以及主板平台</strong>，然后加载<strong>引导设备</strong>的第一个扇区数据，到0x7c00地址开始的<strong>内存空间</strong>，然后再接着跳转到0x7c00处<strong>执行指令</strong>，在我们这里的情况下就是GRUB引导程序。</p><h2 id="Hello-OS引导汇编代码"><a href="#Hello-OS引导汇编代码" class="headerlink" title="Hello OS引导汇编代码"></a>Hello OS引导汇编代码</h2><h3 id="为什么不用C？"><a href="#为什么不用C？" class="headerlink" title="为什么不用C？"></a>为什么不用C？</h3><p>C 作为通用的高级语言，<strong>不能直接操作特定的硬件</strong>，而且 C 语言的函数调用、函数传参，都需要用<strong>栈</strong>。</p><h3 id="汇编部分的主要功能模块："><a href="#汇编部分的主要功能模块：" class="headerlink" title="汇编部分的主要功能模块："></a>汇编部分的主要功能模块：</h3><p>1、GRUB多引导协议标准。</p><p>2、关掉中断，设定CPU的工作模式</p><p>3、初始化CPU的寄存器和C语言的运行环境</p><p>4、初始化工作模式的数据，会调用C语言写的主函数</p><h2 id="控制计算机屏幕"><a href="#控制计算机屏幕" class="headerlink" title="控制计算机屏幕"></a>控制计算机屏幕</h2><p>显卡的字符模式的工作细节：</p><p>它把屏幕分成 24 行，每行 80 个字符，把这（24*80）个位置映射到以 <strong>0xb8000</strong> 地址开始的内存中，每两个字节对应一个字符，其中一个字节是字符的 ASCII 码，另一个字节为字符的颜色值。如下图所示：</p><img src="https://phkblog-1307710240.cos.ap-beijing.myqcloud.com/image-20221031160920947.png" alt="计算机显卡文本工作模式" style="zoom:150%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> _strwrite(<span class="hljs-type">char</span>* <span class="hljs-built_in">string</span>)<br>&#123;<br>  <span class="hljs-type">char</span>* p_strdst = (<span class="hljs-type">char</span>*)(<span class="hljs-number">0xb8000</span>);<span class="hljs-comment">//指向显存的开始地址</span><br>  <span class="hljs-keyword">while</span> (*<span class="hljs-built_in">string</span>)<br>  &#123;<br>    *p_strdst = *<span class="hljs-built_in">string</span>++;<br>    p_strdst += <span class="hljs-number">2</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">printf</span><span class="hljs-params">(<span class="hljs-type">char</span>* fmt, ...)</span><br>&#123;<br>  _strwrite(fmt);<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//printf 函数直接调用了 _strwrite 函数，</span><br><span class="hljs-comment">//而 _strwrite 函数正是将字符串里每个字符依次定入到 0xb8000 地址开始的显存中，</span><br><span class="hljs-comment">//而 p_strdst 每次加 2，这也是为了跳过字符的颜色信息的空间。</span><br><br></code></pre></td></tr></table></figure><h2 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><br>CC = gcc <span class="hljs-comment">#定义一个宏CC 等于gcc</span><br>CFLAGS = -c <span class="hljs-comment">#定义一个宏 CFLAGS 等于-c</span><br>OBJS_FILE = file.o file1.o file2.o file3.o file4.o <span class="hljs-comment">#定义一个宏</span><br>.PHONY : all everything <span class="hljs-comment">#定义两个伪目标all、everything</span><br><span class="hljs-section">all:everything #伪目标all依赖于伪目标everything</span><br>everything :<span class="hljs-variable">$(OBJS_FILE)</span> <span class="hljs-comment">#伪目标everything依赖于OBJS_FILE，而OBJS_FILE是宏会被</span><br><span class="hljs-comment">#替换成file.o file1.o file2.o file3.o file4.o</span><br>%.o : %.c<br>   <span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br></code></pre></td></tr></table></figure><h2 id="Linux-0-11-引导流程"><a href="#Linux-0-11-引导流程" class="headerlink" title="Linux 0.11 引导流程"></a>Linux 0.11 引导流程</h2><h3 id="总体功能介绍"><a href="#总体功能介绍" class="headerlink" title="总体功能介绍"></a>总体功能介绍</h3><p>1、PC电源启动，80x86结构的CPU自动进入<strong>实模式</strong>。从地址<strong>0xFFFF0</strong>开始自动执行程序代码，地址通常是ROM-BIOS的地址。</p><p><strong>实模式介绍</strong>：内存寻址方式和8086相同，当时由于CPU的性能有限，一共只有20位地址线（所以地址空间只有1MB），以及8个16位的通用寄存器，以及4个16位的段寄存器。所以为了能够通过这些16位的寄存器去构成20位的主存地址，必须采取一种特殊的方式。当某个指令想要访问某个内存地址时，它通常需要用下面的这种格式来表示：(段基址：段偏移量)</p><p>2、PC机从物理地址0处开始<em>初始化中断向量</em>，之后启动设备的第一个扇区（磁盘的引导扇区，512字节）读入到内存的0x7C00处，调到此处开始执行。</p><h3 id="文件功能介绍"><a href="#文件功能介绍" class="headerlink" title="文件功能介绍"></a>文件功能介绍</h3><p>boot&#x2F;bootsect.s——（<strong>第一次加载</strong>）将BIOS读入到内存的绝对地址处（0x7C00），（<strong>第一次转移位置</strong>）当他被执行时，会把自己移动到内存0x90000处，并（<strong>第二次加载</strong>）把启动设备中后2KB字节代码（boot&#x2F;setup.s）读入到内存0x90200处，将system模块读入到内存地址0x10000处</p><img src="https://phkblog-1307710240.cos.ap-beijing.myqcloud.com/image-20221031153011708.png" alt="系统加电起，到执行程序的顺序" style="zoom:120%;" /><p>问题1：为什么setup.s要在0x90000处?</p><p>因为system模块长度不会超过512kb(0x80000)字节大小，将setup.s放在0x90000是安全的.</p><p>问题2：system模块要从0x10000处开始加载？</p><p>因为setup代码执行可能会利用ROM BIOS的中断调用来获取机器参数。BIOS初始化会在物理内存开始处放一个0x400的中断向量表。</p><p>问题3：为什么要把bootsect.s转移到0x90000?</p><p>bootsect在执行过程中会加载system模块进入内存，并放置在0x10000处，system模块的大小不超过512kB的空间，所以从0x10000到0x8ffff都是预留给system模块的，为保证bootsect正常执行，需要把自己放在0x90000处开始执行。</p><img src="https://phkblog-1307710240.cos.ap-beijing.myqcloud.com/image-20221031153100216.png" alt="启动引导内核在内存中位置和移动后的位置情况" style="zoom:110%;" /><p>setup会识别硬件参数，并将整个系统从地址0x10000移动到0处，进入保护模式跳转到系统的余下部分</p>]]></content>
    
    
    
    <tags>
      
      <tag>汇编 make</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/2022/10/30/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2022/10/30/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1 id="最简单的LIS系列"><a href="#最简单的LIS系列" class="headerlink" title="最简单的LIS系列"></a>最简单的LIS系列</h1><h2 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a><a href="https://leetcode.cn/problems/longest-consecutive-sequence/">最长连续序列</a></h2><img src="https://phkblog-1307710240.cos.ap-beijing.myqcloud.com/image-20221030200358187.png" alt="最长严格递增的子序列例子" style="zoom: 20%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Cpp"><span class="hljs-comment">// 法1-动态规划</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 数组长度</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">len</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;     <span class="hljs-comment">// dp[i]---以第i个元素作为结尾的最长严格递增的子序列长度</span><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;               <span class="hljs-comment">// 记录最长</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; ++j)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] &lt; nums[i])<br>            &#123;<br>                <span class="hljs-comment">// 如果发现了前面的有一个元素比我的更小，就说明可以累加上</span><br>                len[i] = <span class="hljs-built_in">max</span>(len[j] + <span class="hljs-number">1</span>, len[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 更新res</span><br>        res = <span class="hljs-built_in">max</span>(res, len[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>贪心的想，我们是想让我们的数列增长的越来越慢，增长的越慢，最终子序列的长度就越长。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();           <span class="hljs-comment">// 数组长度</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; subsequence = &#123;nums[<span class="hljs-number">0</span>]&#125;; <span class="hljs-comment">//第一个默认第一个元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (subsequence.<span class="hljs-built_in">back</span>() &lt; nums[i])<br>        &#123;<br>            subsequence.<span class="hljs-built_in">push_back</span>(nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">// 二分查找，找到新来的元素的位置</span><br>            <span class="hljs-keyword">auto</span> t = <span class="hljs-built_in">lower_bound</span>(subsequence.<span class="hljs-built_in">begin</span>(), subsequence.<span class="hljs-built_in">end</span>(), nums[i]);<br>            *t = nums[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> subsequence.<span class="hljs-built_in">size</span>();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>线性动态规划 区间动态规划 前缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统实战1-程序如何运行的</title>
    <link href="/2022/10/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2-%E7%AC%AC%E4%B8%80%E8%AE%B2/"/>
    <url>/2022/10/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2-%E7%AC%AC%E4%B8%80%E8%AE%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="程序如何运行起来的？"><a href="#程序如何运行起来的？" class="headerlink" title="程序如何运行起来的？"></a>程序如何运行起来的？</h1><p>参考：<a href="https://time.geekbang.org/article/369457?code=Wsnr97yd4YlBVh6-MIULynIv89rgEjd5QOG0Z1a9Jp0=">https://time.geekbang.org/article/369457?code=Wsnr97yd4YlBVh6-MIULynIv89rgEjd5QOG0Z1a9Jp0%3D</a> 和 CSAPP</p><h2 id="程序的编译过程"><a href="#程序的编译过程" class="headerlink" title="程序的编译过程"></a>程序的编译过程</h2><img src="https://phkblog-1307710240.cos.ap-beijing.myqcloud.com/image-20221027161442149.png" alt="编译四部曲" style="zoom:150%;" /><ol><li><p><strong>预处理</strong>：预处理器（cpp）</p><p>​      将源程序进行预处理替换。例如#include XXX，就会将XXX文件内容替换到这个源程序中 #define  XXX进行宏替换 #ifndef 将不必要的代码进行过滤。<em>注意typedef不是简单替换</em>。</p></li><li><p><strong>编译</strong>：编译器（ccl）</p><p>​       将预处理的源文件（.i 文件）编译成汇编语言程序。.s<br>​       通过词法分析与语法分析，再确认所有指令符合语法规则后，将其<strong>翻译为等价的代码表达式汇编代码</strong>。</p></li><li><p><strong>汇编</strong>：汇编器（as）</p><p>​      汇编器将hello.s翻译成机器指令，将指令打包成一种”可重定位的目标程序，并将结果保存在目标文件中“目标文件分成两段：<br>​       代码段：程序指令，可读、可执行、不可写<br>​       数据段：放程序的全局变量或者静态变量</p></li><li><p><strong>链接</strong>：链接器（ld）</p><p>​       将有关的<strong>目标文件</strong>彼此链接，也将在一个<strong>文件中引用的符号</strong>同<strong>该符号</strong>在<strong>另一个文件</strong>中定义<strong>链接在一起</strong>，使得所有这些目标文件成为一个<strong>可以装入操作系统</strong>的<strong>统一整体</strong>。</p><p>​       结果就得到 hello 文件，它是一个可执行目标文件（或者简称为可执行文件），可以被加载到内存中，由系统执行。</p></li></ol><img src="https://phkblog-1307710240.cos.ap-beijing.myqcloud.com/image-20221030161348684.png" alt="编译流程" style="zoom:67%;" /><h2 id="程序装载执行"><a href="#程序装载执行" class="headerlink" title="程序装载执行"></a>程序装载执行</h2><h3 id="图灵机"><a href="#图灵机" class="headerlink" title="图灵机"></a>图灵机</h3><p>图灵机是一个抽象的模型，它是这样的：有一条<strong>无限长</strong>的纸带，纸带上有无限个小格子，小格子中写有相关的信息，纸带上有一个<strong>读头</strong>，读头能根据纸带小格子里的信息做相关的操作并能<strong>来回移动</strong>。</p><img src="https://phkblog-1307710240.cos.ap-beijing.myqcloud.com/image-20221030161543221.png" alt="图灵机模型" style="zoom:150%;" /><h3 id="冯诺依曼体系结构"><a href="#冯诺依曼体系结构" class="headerlink" title="冯诺依曼体系结构"></a>冯诺依曼体系结构</h3><p><strong>电子计算机使用二进制数制系统和储存程序，并按照程序顺序执行。</strong>冯诺依曼体系结构的核心</p><p>根据冯诺依曼体系结构构成的计算机，必须具有如下功能以及组件：</p><table><thead><tr><th>功能</th><th>组件</th></tr></thead><tbody><tr><td>把程序和数据装入到计算机中</td><td>装载数据和程序的输入设备</td></tr><tr><td>必须具有长期记住程序、数据的中间结果及最终运算结果</td><td>记住程序和数据的存储器</td></tr><tr><td>完成各种算术、逻辑运算和数据传送等数据加工处理</td><td>完成数据加工处理的运算器</td></tr><tr><td>根据需要控制程序走向，并能根据指令控制机器的各部件协调操作</td><td>控制程序执行的控制器</td></tr><tr><td>能够按照要求将处理的数据结果显示给用户</td><td>显示处理结果的输出设备。</td></tr></tbody></table><h2 id="HelloWord程序装入原型计算机"><a href="#HelloWord程序装入原型计算机" class="headerlink" title="HelloWord程序装入原型计算机"></a>HelloWord程序装入原型计算机</h2><p>对hello进行反编译操作，使用odjump操作，以下main部分函数代码</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">000000000000063a</span> &lt;main&gt;:<br>  <span class="hljs-attribute">1</span>列         <span class="hljs-number">2</span>列                            <span class="hljs-number">3</span>列                            <span class="hljs-number">4</span>列<br> <span class="hljs-attribute">63a</span>:<span class="hljs-number">55</span>                   push   %rbp<br> <span class="hljs-attribute">63b</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> e5             mov    %rsp,%rbp<br> <span class="hljs-attribute">63e</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">10</span>          sub    $<span class="hljs-number">0</span>x10,%rsp<br> <span class="hljs-attribute">642</span>:<span class="hljs-number">89</span> <span class="hljs-number">7</span>d fc             mov    %edi,-<span class="hljs-number">0</span>x4(%rbp)<br> <span class="hljs-attribute">645</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">75</span> f0          mov    %rsi,-<span class="hljs-number">0</span>x10(%rbp)<br> <span class="hljs-attribute">649</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">3</span>d <span class="hljs-number">94</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> lea    <span class="hljs-number">0</span>x94(%rip),%rdi        # <span class="hljs-number">6</span>e4 &lt;_IO_stdin_used+<span class="hljs-number">0</span>x4&gt;<br> <span class="hljs-attribute">650</span>:e8 bb fe ff ff       callq  <span class="hljs-number">510</span> &lt;puts@plt&gt;<br> <span class="hljs-attribute">655</span>:b8 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x0,%eax<br> <span class="hljs-attribute">65a</span>:c9                   leaveq <br> <span class="hljs-attribute">65b</span>:c3                   retq   <br> <span class="hljs-attribute">65c</span>:<span class="hljs-number">0</span>f <span class="hljs-number">1</span>f <span class="hljs-number">40</span> <span class="hljs-number">00</span>          nopl   <span class="hljs-number">0</span>x0(%rax)<br></code></pre></td></tr></table></figure><p>分成四列：第一列为<strong>地址</strong>；第二列为十六进制，表示<strong>真正装入机器中的代码数据</strong>；第三列是对应的汇编代码；第四列是相关代码的注释。这是 x86_64 体系的代码，由此可以看出 x86 CPU 是变长指令集。</p><img src="https://phkblog-1307710240.cos.ap-beijing.myqcloud.com/image-20221030162808811.png" alt="helloworld文件加载到冯诺依曼模型" style="zoom:150%;" /><p>CPU在图灵机纸带上操作</p><h2 id="思考：call-和-ret-指令在逻辑上执行的操作？"><a href="#思考：call-和-ret-指令在逻辑上执行的操作？" class="headerlink" title="思考：call 和 ret 指令在逻辑上执行的操作？"></a>思考：call 和 ret 指令在逻辑上执行的操作？</h2><p>为了实现 C 语言中函数的调用和返回功能，CPU 实现了函数调用和返回指令，即上图汇编代码中的“call”，“ret”指令，请你思考一下：call 和 ret 指令在逻辑上执行的操作是怎样的呢？</p><p> 首先假设CPU执行指令是顺序执行的，那么程序的调用需要考虑几个问题: </p><p>1，call指令要执行的代码在哪？也就是被调用函数的第一条指令所在的内存地址 </p><p>2，被调用函数执行完之后，返回哪个位置继续执行？ </p><p>只要解决<strong>上面这两个问题</strong>，那么函数调用时指令的间的跳转就迎刃而解了。 </p><p>针对第一个问题，在gcc编译完成之后，<strong>函数对应的指令序列所在的位置就已经确定了</strong>，因此这是编译阶段需要考虑的问题 </p><p>至于第二个问题，<strong>在执行完call指令的同时</strong>，需要将call指令下面一条<strong>指令的地址保存到栈内存中</strong>，同时更新%rsp寄存器指向的位置，然后就可以开始执行被调函数的指令序列，执行完毕后，<strong>由ret指令从rsp中获取栈顶的returnadress地址</strong>，然后跳转到call的下一条指令继续执行。</p>]]></content>
    
    
    
    <tags>
      
      <tag>图灵 冯诺依曼</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣每日一题</title>
    <link href="/2022/10/27/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    <url>/2022/10/27/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="2022-10-27-数组元素积的符号"><a href="#2022-10-27-数组元素积的符号" class="headerlink" title="2022-10-27 数组元素积的符号"></a><a href="https://leetcode.cn/problems/sign-of-the-product-of-an-array/">2022-10-27 数组元素积的符号</a></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">arraySign</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-comment">// 记录负数的个数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;num : nums)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">// 检测到了0，直接返回0</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            ++res;<span class="hljs-comment">// 检测到了负数+1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;<span class="hljs-comment">// 负数是偶数则1，反之为-1</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2022-10-28-子数组的最小值之和"><a href="#2022-10-28-子数组的最小值之和" class="headerlink" title="2022-10-28 子数组的最小值之和"></a><a href="https://leetcode.cn/problems/sum-of-subarray-minimums/">2022-10-28 子数组的最小值之和</a></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//方法1 动态规划</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumSubarrayMins</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 数组的长度</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;     <span class="hljs-comment">// dp[i] 以下标i结尾的所有的子数组的最小值之和</span><br>    dp[<span class="hljs-number">0</span>] = arr[<span class="hljs-number">0</span>];           <span class="hljs-comment">// 第一个以自己为结尾</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &gt;= <span class="hljs-number">0</span>; --j)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &lt; arr[i]) <span class="hljs-comment">// 遇到了一个比我当前还要小的数字下标</span><br>            &#123;<br>                dp[i] += dp[j]; <span class="hljs-comment">// 将当前的下标记录下来</span><br>                dp[i] %= MOD;<br>                <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 这时候没有必要再去遍历后面的内容</span><br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">// 大于等于的算是当前的加上s</span><br>                dp[i] += arr[i];<br>                dp[i] %= MOD;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">accumulate</span>(dp.<span class="hljs-built_in">begin</span>(), dp.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://phkblog-1307710240.cos.ap-beijing.myqcloud.com/image-20221028150439834.png" alt="单调栈方法的样例示意" style="zoom:150%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">// 动态规划 + 单调栈</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumSubarrayMins</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 数组的长度</span><br>    stack&lt;<span class="hljs-type">int</span>&gt; help_index;    <span class="hljs-comment">// 单调栈</span><br>    help_index.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>    dp[<span class="hljs-number">0</span>] = arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> res = dp[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (!help_index.<span class="hljs-built_in">empty</span>() &amp;&amp; arr[i] &lt; arr[help_index.<span class="hljs-built_in">top</span>()])<br>        &#123;<br>            <span class="hljs-comment">// help_index不是空的，当前位置小于stack前面的这个</span><br>            help_index.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (help_index.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-comment">// 遇到了最小的，以当前位为结尾的最小</span><br>            dp[i] = (i + <span class="hljs-number">1</span>) * arr[i] % MOD;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">// 单调栈内部还有东西，说明当前的不是最小</span><br>            dp[i] = ((i - help_index.<span class="hljs-built_in">top</span>()) * arr[i] + dp[help_index.<span class="hljs-built_in">top</span>()]) % MOD;<br>        &#125;<br>        res = (res + dp[i]) % MOD;<br>        help_index.<span class="hljs-built_in">emplace</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2022-10-29-统计匹配检索规则的物品数量"><a href="#2022-10-29-统计匹配检索规则的物品数量" class="headerlink" title="2022-10-29 统计匹配检索规则的物品数量"></a><a href="https://leetcode.cn/problems/count-items-matching-a-rule/">2022-10-29 统计匹配检索规则的物品数量</a></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Cpp"><span class="hljs-comment">// 遍历 简单题</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countMatches</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt;&amp; items, string ruleKey, string ruleValue)</span> </span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-comment">// 累计个数</span><br>    <span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;<span class="hljs-comment">// 标志位，以哪一个为中心</span><br>    <span class="hljs-keyword">if</span> (ruleKey == <span class="hljs-string">&quot;color&quot;</span>) &#123;<br>        flag = <span class="hljs-number">1</span>;<span class="hljs-comment">//颜色则为1</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ruleKey == <span class="hljs-string">&quot;name&quot;</span>) &#123;<br>        flag = <span class="hljs-number">2</span>;<span class="hljs-comment">//名字则为2</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> <span class="hljs-type">const</span> &amp;vec:items) &#123;<br>        <span class="hljs-keyword">if</span> (ruleValue == vec[flag]) res++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2022-10-30-字母大小写全排列"><a href="#2022-10-30-字母大小写全排列" class="headerlink" title="2022-10-30 字母大小写全排列"></a><a href="https://leetcode.cn/problems/letter-case-permutation/">2022-10-30 字母大小写全排列</a></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs Cpp">vector&lt;string&gt; res; <span class="hljs-comment">// 存储结果</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string &amp;cur, string &amp;source, <span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 递归终止条件</span><br>    <span class="hljs-keyword">if</span> (cur.<span class="hljs-built_in">size</span>() == source.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        res.<span class="hljs-built_in">push_back</span>(cur);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 遇到数字直接加进去然后进行后续</span><br>    <span class="hljs-keyword">if</span> (source[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; source[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)<br>    &#123;<br>        cur.<span class="hljs-built_in">push_back</span>(source[i]);<br>        <span class="hljs-built_in">dfs</span>(cur, source, i + <span class="hljs-number">1</span>);<br>        cur.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">// 先将原来的情况进行一次dfs</span><br>        <span class="hljs-type">char</span> next = source[i];<br>        cur.<span class="hljs-built_in">push_back</span>(next);<br>        <span class="hljs-built_in">dfs</span>(cur, source, i + <span class="hljs-number">1</span>);<br>        cur.<span class="hljs-built_in">pop_back</span>();<br>        <span class="hljs-comment">// 进行反转后之后，再进行一次dfs</span><br>        <span class="hljs-keyword">if</span> (next &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; next &lt;= <span class="hljs-string">&#x27;z&#x27;</span>)<br>        &#123;<br>            next = <span class="hljs-string">&#x27;A&#x27;</span> + next - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            next = <span class="hljs-string">&#x27;a&#x27;</span> + next - <span class="hljs-string">&#x27;A&#x27;</span>;<br>        &#125;<br>        cur.<span class="hljs-built_in">push_back</span>(next);<br>        <span class="hljs-built_in">dfs</span>(cur, source, i + <span class="hljs-number">1</span>);<br>        cur.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">letterCasePermutation</span><span class="hljs-params">(string s)</span></span><br><span class="hljs-function"></span>&#123;<br>    std::string c;<br>    <span class="hljs-built_in">dfs</span>(c, s, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2022-10-31神奇字符串"><a href="#2022-10-31神奇字符串" class="headerlink" title="2022-10-31神奇字符串"></a><a href="https://leetcode.cn/problems/magical-string/">2022-10-31神奇字符串</a></h2><p><a href="https://leetcode.cn/problems/magical-string/solution/by-endlesscheng-z8o1/">https://leetcode.cn/problems/magical-string/solution/by-endlesscheng-z8o1/</a></p><p>解析的很好</p><img src="https://phkblog-1307710240.cos.ap-beijing.myqcloud.com/image-20221031151646377.png" alt="初始位置i在末尾" style="zoom:70%;" /><img src="https://phkblog-1307710240.cos.ap-beijing.myqcloud.com/image-20221031151709168.png" alt="i右移" style="zoom:70%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 双指针模拟</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">magicalString</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    std::string s = <span class="hljs-string">&quot;122&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; s.<span class="hljs-built_in">size</span>() &lt; n <span class="hljs-comment">/*累计字符串长度是小于n*/</span>; ++i)<br>    &#123;<br>        <span class="hljs-type">int</span> num = s[i] - <span class="hljs-string">&#x27;0&#x27;</span>;     <span class="hljs-comment">// 要新加的元素的个数</span><br>        <span class="hljs-type">char</span> cur_back = s.<span class="hljs-built_in">back</span>(); <span class="hljs-comment">// 获取得到尾部当前位置的元素</span><br>        <span class="hljs-type">char</span> next = <span class="hljs-string">&#x27;1&#x27;</span>;          <span class="hljs-comment">// 和尾部不同的元素</span><br>        <span class="hljs-keyword">if</span> (cur_back == <span class="hljs-string">&#x27;1&#x27;</span>)<br>        &#123;<br>            next = <span class="hljs-string">&#x27;2&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            next = <span class="hljs-string">&#x27;1&#x27;</span>;<br>        &#125;<br>        s += <span class="hljs-built_in">string</span>(num, next); <span class="hljs-comment">// 将尾部元素加入到结尾</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">count</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">begin</span>() + n, <span class="hljs-string">&#x27;1&#x27;</span>); <span class="hljs-comment">// 累计的1的个数</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2022-11-1检查两个字符串数组是否相等"><a href="#2022-11-1检查两个字符串数组是否相等" class="headerlink" title="2022-11-1检查两个字符串数组是否相等"></a><a href="https://leetcode.cn/problems/check-if-two-string-arrays-are-equivalent/">2022-11-1检查两个字符串数组是否相等</a></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 双指针模拟检查</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">arrayStringsAreEqual</span><span class="hljs-params">(vector&lt;string&gt; &amp;word1, vector&lt;string&gt; &amp;word2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> p1 = <span class="hljs-number">0</span>, p2 = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (p1 &lt; word1.<span class="hljs-built_in">size</span>() &amp;&amp; p2 &lt; word2.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-comment">// p1和p2是两个words字典的指针</span><br>        <span class="hljs-keyword">if</span> (word1[p1][i] != word2[p2][j])<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        ++i;<br>        ++j;<br>        <span class="hljs-keyword">if</span> (i == word1[p1].<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-comment">// 判断是否走完p1的字符串</span><br>            ++p1;<br>            i = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (j == word2[p2].<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-comment">// 判断是否走完p2的字符串</span><br>            ++p2;<br>            j = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p1 == word1.<span class="hljs-built_in">size</span>() &amp;&amp; p2 == word2.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">//是否走完了所有的数据</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2022-11-2-网络信号最好的坐标"><a href="#2022-11-2-网络信号最好的坐标" class="headerlink" title="2022-11-2 网络信号最好的坐标"></a><a href="https://leetcode.cn/problems/coordinate-with-maximum-network-quality/">2022-11-2 网络信号最好的坐标</a></h2><p>穷举</p><h2 id="2022-11-4-到达终点数字"><a href="#2022-11-4-到达终点数字" class="headerlink" title="2022-11-4 到达终点数字"></a><a href="https://leetcode.cn/problems/reach-a-number/">2022-11-4 到达终点数字</a></h2><p><a href="https://leetcode.cn/problems/reach-a-number/solution/by-ac_oier-o4ze/">https://leetcode.cn/problems/reach-a-number/solution/by-ac_oier-o4ze/</a></p><p>通过这篇文章看懂的</p><p><img src="https://phkblog-1307710240.cos.ap-beijing.myqcloud.com/image-20221104120617686.png" alt="image-20221104120617686"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">reachNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> target)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (target &lt; <span class="hljs-number">0</span>)<br>        target = -target;<br>    <span class="hljs-type">int</span> k = <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span> * target), dist = k * (k + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; <span class="hljs-comment">// 以sqrt(2*target)为起点</span><br>    <span class="hljs-keyword">while</span> (dist &lt; target || (dist - target) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<br>    &#123;<br>        ++k;                    <span class="hljs-comment">// 多走一步</span><br>        dist = k * (k + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; <span class="hljs-comment">//更新距离</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> k;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>每天一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP第一章 计算机系统漫游</title>
    <link href="/2022/10/27/CSAPP%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/"/>
    <url>/2022/10/27/CSAPP%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-1-信息就是-位-上下文"><a href="#1-1-信息就是-位-上下文" class="headerlink" title="1.1 信息就是 位 + 上下文"></a>1.1 信息就是 位 + 上下文</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// ---hello.c---</span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>hello.c 程序是以字节序列的方式储存在文件中的（<em>这种方式实际上就是用一个唯一的单字节大小的✦整数值✦来表示每个字符）</em>，每个字节都有一个整数值，对应于某些字符。</p><p>像hello.c这种只是由ASCII字符构成的文件称为 <strong>文本文件</strong></p><p>其他的都是 <strong>二进制文件</strong></p><p>基本思想：<strong>系统中所有的信息</strong>——包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由<strong>一串比特表示的</strong>。<strong>区分</strong>不同数据对象的<strong>唯一方法</strong>是我们读到这些数据对象时的<strong>上下文</strong>。</p><h1 id="1-2-程序被其他程序翻译成不同的格式"><a href="#1-2-程序被其他程序翻译成不同的格式" class="headerlink" title="1.2 程序被其他程序翻译成不同的格式"></a>1.2 程序被其他程序翻译成不同的格式</h1><img src="https://phkblog-1307710240.cos.ap-beijing.myqcloud.com/image-20221027161442149.png" alt="编译四部曲" style="zoom:150%;" /><ol><li><p><strong>预处理</strong>：预处理器（cpp）</p><p>​      将源程序进行预处理替换。例如#include XXX，就会将XXX文件内容替换到这个源程序中 #define  XXX进行宏替换 #ifndef 将不必要的代码进行过滤。<em>注意typedef不是简单替换</em>。</p></li><li><p><strong>编译</strong>：编译器（ccl）</p><p>​       将预处理的源文件（.i 文件）编译成汇编语言程序。.s<br>​       通过词法分析与语法分析，再确认所有指令符合语法规则后，将其<strong>翻译为等价的代码表达式汇编代码</strong>。</p></li><li><p><strong>汇编</strong>：汇编器（as）</p><p>​      汇编器将hello.s翻译成机器指令，将指令打包成一种”可重定位的目标程序，并将结果保存在目标文件中“目标文件分成两段：<br>​       代码段：程序指令，可读、可执行、不可写<br>​       数据段：放程序的全局变量或者静态变量</p></li><li><p><strong>链接</strong>：链接器（ld）</p><p>​       将有关的<strong>目标文件</strong>彼此链接，也将在一个<strong>文件中引用的符号</strong>同<strong>该符号</strong>在<strong>另一个文件</strong>中定义<strong>链接在一起</strong>，使得所有这些目标文件成为一个<strong>可以装入操作系统</strong>的<strong>统一整体</strong>。</p><p>​       结果就得到 hello 文件，它是一个可执行目标文件（或者简称为可执行文件），可以被加载到内存中，由系统执行。</p></li></ol><h1 id="1-4-处理器-读并解释-存储在内存中的指令"><a href="#1-4-处理器-读并解释-存储在内存中的指令" class="headerlink" title="1.4 处理器 读并解释 存储在内存中的指令"></a>1.4 处理器 读并解释 存储在内存中的指令</h1><h2 id="1-4-1系统的硬件组成"><a href="#1-4-1系统的硬件组成" class="headerlink" title="1.4.1系统的硬件组成"></a>1.4.1系统的硬件组成</h2><blockquote><p>经典的系统硬件四个部分</p><p>CPU：中央处理单元；ALU：算术&#x2F;逻辑单元；PC：程序计数器；USB：通用串行总线</p></blockquote><img src="https://phkblog-1307710240.cos.ap-beijing.myqcloud.com/image-20221029191328109.png" alt="intel系统产品族的模型" style="zoom:80%;" /><h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><p>通常总线被设计成传送定长的字节块，也就是<strong>字（word）</strong>。字中的字节数（即字长）是一个基本的系统参数，各个系统中都不尽相同。现在的大多数机器字长要么是 4 个字节（32 位），要么是 8 个字节（64 位）。</p><h3 id="I-x2F-O设备"><a href="#I-x2F-O设备" class="headerlink" title="I&#x2F;O设备"></a>I&#x2F;O设备</h3><p>最初可执行程序是放在磁盘中。<br>每个 I&#x2F;O 设备都通过一个<strong>控制器</strong>或<strong>适配器</strong>与 I&#x2F;O 总线相连。控制器和适配器之间的<strong>区别</strong>主要在于它们的封装方式。控制器是 I&#x2F;O 设备本身或者系统的主印制电路板（通常称作主板）上的<strong>芯片组</strong>。而适配器则是一块<strong>插在主板插槽上的卡</strong>。无论如何，它们的功能都是在 I&#x2F;O 总线和 I&#x2F;O 设备之间传递信息。</p><h3 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h3><p>主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组<strong>动态随机存取存储器</strong>（DRAM）芯片组成的。</p><p>从逻辑上看：主存就是一个线性字节数组，每个字节都有唯一的地址（类似数组的索引），这些地址是从0开始的。<br>一般来说，组成程序的每条机器指令都是由不同数量的字节构成。</p><h3 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h3><p>CPU是解释（或执行）存储在主存中指令的引擎。<br>处理器的核心是一个大小为<strong>一个字</strong>的存储设备（或<strong>寄存器</strong>），称为<strong>程序计数器</strong>（PC）。<br>在任何时刻，PC 都指向主存中的<strong>某条机器语言指令</strong>（即含有该条指令的地址）。</p><p>从系统通电开始，直到系统断电，处理器一直<strong>执行</strong>程序计数器指向的指令，然后再<strong>更新</strong>程序计数器，使其指向下一条指令。</p><h2 id="1-4-2-运行hello程序"><a href="#1-4-2-运行hello程序" class="headerlink" title="1.4.2 运行hello程序"></a>1.4.2 运行hello程序</h2><ol><li><p>shell程序执行指令，等我们输入一个命令。当我们在键盘上输入字符串“.&#x2F;hello”，<strong>shell程序将字符逐一读入寄存器中，再把它放到内存中</strong>。遇到回车，结束命令输入。</p><img src="https://phkblog-1307710240.cos.ap-beijing.myqcloud.com/image-20221030185001352.png" alt="键盘输入指令./hello指令" style="zoom: 80%;" /></li><li><p>shell开始<strong>执行指令</strong>来<strong>加载可执行hello文件</strong>，并且这些指令将<strong>hello目标文件中的代码和数据</strong>从磁盘复制到主存。其中数据包括最终会被输出的字符串“hello world\n”</p></li><li><p>利用DMA技术，数据可以不通过处理器而直接从磁盘到达主存中。</p><img src="https://phkblog-1307710240.cos.ap-beijing.myqcloud.com/image-20221030185054412.png" alt="DMA技术" style="zoom: 80%;" /></li><li><p>目标文件hello中的<strong>代码和数据</strong>被加载到主存，处理器就开始执行hello程序的main程序中的机器语言指令。这些指令将“hello world\n”字符串中的字节从<strong>内存复制到寄存器文件</strong>，再从<strong>寄存器文件中复制到显示设备</strong>。<img src="https://phkblog-1307710240.cos.ap-beijing.myqcloud.com/image-20221030185121930.png" alt="运行hello程序显示结果" style="zoom:50%;" /></p></li></ol><h1 id="1-5-高速缓存至关重要"><a href="#1-5-高速缓存至关重要" class="headerlink" title="1.5 高速缓存至关重要"></a>1.5 高速缓存至关重要</h1><h2 id="1-5-1-CPU运行速度很快，磁盘读写很慢，如何解决速度差"><a href="#1-5-1-CPU运行速度很快，磁盘读写很慢，如何解决速度差" class="headerlink" title="1.5.1 CPU运行速度很快，磁盘读写很慢，如何解决速度差"></a>1.5.1 CPU运行速度很快，磁盘读写很慢，如何解决速度差</h2><p>​       针对这种处理器与主存之间的差异，系统设计者采用了更小更快的存储设备，称为<strong>高速缓存存储器</strong>（cache memory，简称为 cache 或高速缓存），作为暂时的集结区域，存放处理器近期可能会需要的信息。<br>​        比较新的、处理能力更强大的系统甚至有三级高速缓存∶L1、L2 和 L3。系统可以获得一个很大的存储器，同时访问速度也很快，原因是利用了<strong>高速缓存的局部性原理</strong>：即程序具有访问局部区域里的数据和代码的趋势。通过让高速缓存里存放可能经常访问的数据，大部分的内存操作都能在快速的高速缓存中完成。</p><h1 id="1-6-存储设备形成层次结构"><a href="#1-6-存储设备形成层次结构" class="headerlink" title="1.6 存储设备形成层次结构"></a>1.6 存储设备形成层次结构</h1><img src="https://phkblog-1307710240.cos.ap-beijing.myqcloud.com/image-20221030191316798.png" alt="存储器层次结构示例" style="zoom:80%;" /><p>经典图例，多级缓存来提高计算机的运行速度</p><h1 id="1-7-操作系统管理硬件"><a href="#1-7-操作系统管理硬件" class="headerlink" title="1.7 操作系统管理硬件"></a>1.7 操作系统管理硬件</h1><h2 id="操作系统的作用"><a href="#操作系统的作用" class="headerlink" title="操作系统的作用"></a>操作系统的作用</h2><p>1、防止硬件被失控的应用程序滥用<br>2、向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备</p><p>三个重要概念：</p><p><strong>文件：</strong>对I&#x2F;O设备的抽象表示<br><strong>虚拟内存：</strong>对主存和磁盘IO的抽象<br><strong>进程：</strong>对处理器、主存和IO设备的抽象表示</p><h2 id="1-7-1进程"><a href="#1-7-1进程" class="headerlink" title="1.7.1进程"></a>1.7.1进程</h2><p><strong>进程</strong>是操作系统对一个正在运行的程序的一种抽象</p><p><strong>并发运行</strong>：一个进程的指令和另一个进程的指令是交错执行的。</p><img src="https://phkblog-1307710240.cos.ap-beijing.myqcloud.com/image-20221031184610988.png" alt="进程的上下文切换" style="zoom:80%;" /><p>先进的<strong>多核</strong>处理器同时能够执行多个程序。无论是在单核还是多核系统中，一个 CPU 看上去都像是在并发地执行多个进程，这是通过处理器在进程间切换来实现的。操作系统实现这种交错执行的机制称为<strong>上下文切换</strong>。</p><p>这里上下文切换中，<strong>上下文</strong>是指操作系统保持跟踪运行所要的所有的状态信息。例如：PC和寄存器文件的当前值，以及主存中的内容。<strong>上下文切换三步走</strong>即保存当前进程的上下文、恢复新进程的上下文，然后将控制权传递到新进程。</p><p>从一个进程到另一个进程转换需要经过操作系统<strong>内核</strong>管理。<br>内核是操作系统代码常驻主存的部分。当应用程序需要操作系统的某些操作时，它需要执行一条特殊的<strong>系统调用</strong>指令。</p><p>内核的概念：并非独立进程。而是系统管理<strong>全部进程</strong>所用代码和数据结构的集和。</p><h2 id="1-7-2-线程"><a href="#1-7-2-线程" class="headerlink" title="1.7.2 线程"></a>1.7.2 线程</h2><p>一个进程实际上可以由多个称为<strong>线程</strong>的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。</p><h2 id="1-7-3-虚拟内存"><a href="#1-7-3-虚拟内存" class="headerlink" title="1.7.3 虚拟内存"></a>1.7.3 虚拟内存</h2><p>虚拟内存是一个抽象概念，它为每个进程提供了一个假象，即每个<strong>进程</strong>都在<strong>独占</strong>地使用<strong>主存</strong>。</p><img src="https://phkblog-1307710240.cos.ap-beijing.myqcloud.com/image-20221031190215689.png" alt="虚拟地址空间示例" style="zoom:150%;" /><p><strong>程序代码和数据</strong>。所有的进程，<strong>代码都是同一个固定地址开始</strong>，紧接着是和<strong>C全局变量相对应的数据位置</strong>。代码和数据是直接按照可执行目标文件的内容初始化的。</p><p><strong>堆</strong>。堆是可以运行时动态的扩展和收缩的。</p><p><strong>共享库</strong>。存放类似C标准库和数据库这样共享库的代码和数据的区域。</p><p><strong>栈</strong>。用户虚拟地址空间顶部的是<strong>用户栈</strong>，用户栈在程序执行期间可以动态地扩展和收缩。特别地，每次我们调用一个函数时，栈就会增长；从一个函数返回时，栈就会收缩</p><p><strong>内核虚拟内存</strong>。为内核保留，不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。</p><p>虚拟内存的运作需要硬件和操作系统软件之间精密复杂的交互，包括对处理器生成的每个<strong>地址的硬件翻译</strong>。基本思想是把一个进程<strong>虚拟内存</strong>的内容存储在<strong>磁盘</strong>上，然后用主存作为磁盘的高速缓存。</p><h2 id="1-7-4-文件"><a href="#1-7-4-文件" class="headerlink" title="1.7.4 文件"></a>1.7.4 文件</h2><p>文件本质就是字节序列</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机系统概述 编辑器实现过程调用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP笔记</title>
    <link href="/2022/10/27/CSAPP%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/10/27/CSAPP%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="第一章-计算机系统漫游"><a href="#第一章-计算机系统漫游" class="headerlink" title="第一章 计算机系统漫游"></a>第一章 计算机系统漫游</h2><h1 id="第二部分-程序结构和执行"><a href="#第二部分-程序结构和执行" class="headerlink" title="第二部分 程序结构和执行"></a>第二部分 程序结构和执行</h1><h2 id="第二章-信息的表示和处理"><a href="#第二章-信息的表示和处理" class="headerlink" title="第二章 信息的表示和处理"></a>第二章 信息的表示和处理</h2><h2 id="第三章-程序的机器级表示"><a href="#第三章-程序的机器级表示" class="headerlink" title="第三章 程序的机器级表示"></a>第三章 程序的机器级表示</h2><h2 id="第四章-处理器体系结构"><a href="#第四章-处理器体系结构" class="headerlink" title="第四章 处理器体系结构"></a>第四章 处理器体系结构</h2><h2 id="第五章-优化程序性能"><a href="#第五章-优化程序性能" class="headerlink" title="第五章 优化程序性能"></a>第五章 优化程序性能</h2><h2 id="第六章-存储器层级结构"><a href="#第六章-存储器层级结构" class="headerlink" title="第六章 存储器层级结构"></a>第六章 存储器层级结构</h2>]]></content>
    
    
    
    <tags>
      
      <tag>CSAPP笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络---小林Coding---TCP篇</title>
    <link href="/2022/10/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%B0%8F%E6%9E%97Coding/"/>
    <url>/2022/10/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%B0%8F%E6%9E%97Coding/</url>
    
    <content type="html"><![CDATA[<p>本文主要是在学习<a href="https://xiaolincoding.com/%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%81%9A%E7%9A%84%E7%AC%94%E8%AE%B0">https://xiaolincoding.com/过程中做的笔记</a><br>膜拜小林coding大神！</p><h1 id="TCP基础"><a href="#TCP基础" class="headerlink" title="TCP基础"></a>TCP基础</h1><h2 id="TCP头部格式"><a href="#TCP头部格式" class="headerlink" title="TCP头部格式"></a>TCP头部格式</h2><img src="https://phkblog-1307710240.cos.ap-beijing.myqcloud.com/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzYuanBn" alt="TCP 头格式" style="zoom: 50%;" /><p><strong>序列号</strong>：在建立连接时，由计算机生成的随机数作为初始值，通过SYN包传送给接收端主机，没发送一次数据，就会“累加”一次该”数据字节数”的大小。主要用来解决网络包乱序的问题。</p><p><strong>确认应答号</strong>：指下一次*”期望”<em>收到数据的序列号，发送端收到这个确认应答之后就可以认为在这个序列号以前的数据都已经被正常的接受。主要用来解决</em>丢包*问题。</p><p><strong>控制位</strong>：</p><ul><li><em>ACK</em>：该位为 <code>1</code> 时，确认应答 的字段变为有效，TCP 规定<em><strong>除了</strong>最初建立连接时的 <code>SYN</code> 包之外（第一次握手）</em>该位必须设置为 <code>1</code> 。</li><li><em>RST</em>：该位为 <code>1</code> 时，表示 TCP 连接中<strong>出现异常</strong>必须<strong>强制断开连接</strong>。</li><li><em>SYN</em>：该位为 <code>1</code> 时，表示希望建立连接，并在其 序列号 的字段进行序列号初始值的设定。</li><li><em>FIN</em>：该位为 <code>1</code> 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 <code>FIN</code> 位为 1 的 TCP 段。</li></ul><h2 id="为什么需要TCP协议？"><a href="#为什么需要TCP协议？" class="headerlink" title="为什么需要TCP协议？"></a>为什么需要TCP协议？</h2><p>IP 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。</p><p>如果需要保障网络数据包的可靠性，那么就需要由上层（传输层）的 <code>TCP</code> 协议来负责。</p><p>因为 TCP 是一个工作在<strong>传输层</strong>的<strong>可靠</strong>数据传输的服务，它能确保接收端接收的网络包是  无损坏、无间隔、非冗余和按序的。</p><h2 id="什么是TCP协议？"><a href="#什么是TCP协议？" class="headerlink" title="什么是TCP协议？"></a>什么是TCP协议？</h2><p>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。</p><p>面向连接：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</p><p><a href="#TCP%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E5%8F%AF%E9%9D%A0%E6%80%A7%EF%BC%9F">可靠性</a>：无论的<strong>网络链路中</strong>出现了怎样的链路变化，TCP都可以<strong>保证一个报文一定能够到达接收端</strong>；</p><p>字节流：用户消息通过 TCP 协议传输时，<strong>消息可能会被操作系统「分组」成多个的 TCP 报文</strong>，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。</p><h2 id="TCP如何做到可靠性？"><a href="#TCP如何做到可靠性？" class="headerlink" title="TCP如何做到可靠性？"></a>TCP如何做到可靠性？</h2><p><strong>粗略</strong>：</p><p>因为TCP在<strong>数据传输之前会有三次握手</strong>来进行连接<br>在数据传输时候，有确认、滑动窗口、超时重传、拥塞控制之类机制<br>数据传输之后会进行四次挥手断开连接来节约系统资源。</p><p><strong>具体：</strong></p><p>1、应用数据被分割成TCP认为最适合发送的数据块<br>2、TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。<br>3、校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。<br>4、TCP 的接收端会丢弃重复的数据。<br>5、利用滑动窗口实现流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）<br>6、拥塞控制： 当网络拥塞时，减少数据的发送。<br>7、ARQ协议： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。<br>8、超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络 小林Coding</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>力扣每日一题</title>
    <link href="/2022/10/27/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    <url>/2022/10/27/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="2022-10-27-数组元素积的符号"><a href="#2022-10-27-数组元素积的符号" class="headerlink" title="2022-10-27 数组元素积的符号"></a><a href="https://leetcode.cn/problems/sign-of-the-product-of-an-array/">2022-10-27 数组元素积的符号</a></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">arraySign</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-comment">// 记录负数的个数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;num : nums)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">// 检测到了0，直接返回0</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            ++res;<span class="hljs-comment">// 检测到了负数+1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;<span class="hljs-comment">// 负数是偶数则1，反之为-1</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2022-10-28子数组的最小值之和"><a href="#2022-10-28子数组的最小值之和" class="headerlink" title="2022-10-28子数组的最小值之和"></a><a href="https://leetcode.cn/problems/sum-of-subarray-minimums/">2022-10-28子数组的最小值之和</a></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//方法1 动态规划</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumSubarrayMins</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 数组的长度</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;     <span class="hljs-comment">// dp[i] 以下标i结尾的所有的子数组的最小值之和</span><br>    dp[<span class="hljs-number">0</span>] = arr[<span class="hljs-number">0</span>];           <span class="hljs-comment">// 第一个以自己为结尾</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &gt;= <span class="hljs-number">0</span>; --j)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &lt; arr[i]) <span class="hljs-comment">// 遇到了一个比我当前还要小的数字下标</span><br>            &#123;<br>                dp[i] += dp[j]; <span class="hljs-comment">// 将当前的下标记录下来</span><br>                dp[i] %= MOD;<br>                <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 这时候没有必要再去遍历后面的内容</span><br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">// 大于等于的算是当前的加上s</span><br>                dp[i] += arr[i];<br>                dp[i] %= MOD;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">accumulate</span>(dp.<span class="hljs-built_in">begin</span>(), dp.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://phkblog-1307710240.cos.ap-beijing.myqcloud.com/image-20221028150439834.png" alt="单调栈方法的样例示意" style="zoom:150%;"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">// 动态规划 + 单调栈</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumSubarrayMins</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 数组的长度</span><br>    stack&lt;<span class="hljs-type">int</span>&gt; help_index;    <span class="hljs-comment">// 单调栈</span><br>    help_index.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>    dp[<span class="hljs-number">0</span>] = arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> res = dp[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (!help_index.<span class="hljs-built_in">empty</span>() &amp;&amp; arr[i] &lt; arr[help_index.<span class="hljs-built_in">top</span>()])<br>        &#123;<br>            <span class="hljs-comment">// help_index不是空的，当前位置小于stack前面的这个</span><br>            help_index.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (help_index.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-comment">// 遇到了最小的，以当前位为结尾的最小</span><br>            dp[i] = (i + <span class="hljs-number">1</span>) * arr[i] % MOD;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">// 单调栈内部还有东西，说明当前的不是最小</span><br>            dp[i] = ((i - help_index.<span class="hljs-built_in">top</span>()) * arr[i] + dp[help_index.<span class="hljs-built_in">top</span>()]) % MOD;<br>        &#125;<br>        res = (res + dp[i]) % MOD;<br>        help_index.<span class="hljs-built_in">emplace</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>每天一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP第一章 计算机系统漫游</title>
    <link href="/2022/10/27/CSAPP%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/"/>
    <url>/2022/10/27/CSAPP%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-1-信息就是-位-上下文"><a href="#1-1-信息就是-位-上下文" class="headerlink" title="1.1 信息就是 位 + 上下文"></a>1.1 信息就是 位 + 上下文</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// ---hello.c---</span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>hello.c 程序是以字节序列的方式储存在文件中的（<em>这种方式实际上就是用一个唯一的单字节大小的✦整数值✦来表示每个字符）</em>，每个字节都有一个整数值，对应于某些字符。</p><p>像hello.c这种只是由ASCII字符构成的文件称为 <strong>文本文件</strong></p><p>其他的都是 <strong>二进制文件</strong></p><p>基本思想：<strong>系统中所有的信息</strong>——包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由<strong>一串比特表示的</strong>。<strong>区分</strong>不同数据对象的<strong>唯一方法</strong>是我们读到这些数据对象时的<strong>上下文</strong>。</p><h1 id="1-2-程序被其他程序翻译成不同的格式"><a href="#1-2-程序被其他程序翻译成不同的格式" class="headerlink" title="1.2 程序被其他程序翻译成不同的格式"></a>1.2 程序被其他程序翻译成不同的格式</h1><img src="https://phkblog-1307710240.cos.ap-beijing.myqcloud.com/image-20221027161442149.png" alt="编译四部曲" style="zoom:150%;"><ol><li><p><strong>预处理</strong>：预处理器（cpp）</p><p>​      将源程序进行预处理替换。例如#include XXX，就会将XXX文件内容替换到这个源程序中 #define  XXX进行宏替换 #ifndef 将不必要的代码进行过滤。<em>注意typedef不是简单替换</em>。</p></li><li><p><strong>编译</strong>：编译器（ccl）</p><p>​       将预处理的源文件（.i 文件）编译成汇编语言程序。.s<br>​       通过词法分析与语法分析，再确认所有指令符合语法规则后，将其<strong>翻译为等价的代码表达式汇编代码</strong>。</p></li><li><p><strong>汇编</strong>：汇编器（as）</p><p>​      汇编器将hello.s翻译成机器指令，将指令打包成一种”可重定位的目标程序，并将结果保存在目标文件中“目标文件分成两段：<br>​       代码段：程序指令，可读、可执行、不可写<br>​       数据段：放程序的全局变量或者静态变量</p></li><li><p><strong>链接</strong>：链接器（ld）</p><p>​       将有关的<strong>目标文件</strong>彼此链接，也将在一个<strong>文件中引用的符号</strong>同<strong>该符号</strong>在<strong>另一个文件</strong>中定义<strong>链接在一起</strong>，使得所有这些目标文件成为一个<strong>可以装入操作系统</strong>的<strong>统一整体</strong>。</p><p>​       结果就得到 hello 文件，它是一个可执行目标文件（或者简称为可执行文件），可以被加载到内存中，由系统执行。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>计算机系统概述 编辑器实现过程调用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP笔记</title>
    <link href="/2022/10/27/CSAPP%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/10/27/CSAPP%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id><a href="#" class="headerlink" title></a></h1><h2 id="第一章-计算机系统漫游"><a href="#第一章-计算机系统漫游" class="headerlink" title="第一章 计算机系统漫游"></a>第一章 计算机系统漫游</h2><h1 id="第二部分-程序结构和执行"><a href="#第二部分-程序结构和执行" class="headerlink" title="第二部分 程序结构和执行"></a>第二部分 程序结构和执行</h1><h2 id="第二章-信息的表示和处理"><a href="#第二章-信息的表示和处理" class="headerlink" title="第二章 信息的表示和处理"></a>第二章 信息的表示和处理</h2><h2 id="第三章-程序的机器级表示"><a href="#第三章-程序的机器级表示" class="headerlink" title="第三章 程序的机器级表示"></a>第三章 程序的机器级表示</h2><h2 id="第四章-处理器体系结构"><a href="#第四章-处理器体系结构" class="headerlink" title="第四章 处理器体系结构"></a>第四章 处理器体系结构</h2><h2 id="第五章-优化程序性能"><a href="#第五章-优化程序性能" class="headerlink" title="第五章 优化程序性能"></a>第五章 优化程序性能</h2><h2 id="第六章-存储器层级结构"><a href="#第六章-存储器层级结构" class="headerlink" title="第六章 存储器层级结构"></a>第六章 存储器层级结构</h2>]]></content>
    
    
    
    <tags>
      
      <tag>CSAPP笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络---小林Coding---TCP篇</title>
    <link href="/2022/10/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%B0%8F%E6%9E%97Coding/"/>
    <url>/2022/10/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%B0%8F%E6%9E%97Coding/</url>
    
    <content type="html"><![CDATA[<p>本文主要是在学习<a href="https://xiaolincoding.com/%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%81%9A%E7%9A%84%E7%AC%94%E8%AE%B0">https://xiaolincoding.com/过程中做的笔记</a><br>膜拜小林coding大神！</p><h1 id="TCP基础"><a href="#TCP基础" class="headerlink" title="TCP基础"></a>TCP基础</h1><h2 id="TCP头部格式"><a href="#TCP头部格式" class="headerlink" title="TCP头部格式"></a>TCP头部格式</h2><img src="https://phkblog-1307710240.cos.ap-beijing.myqcloud.com/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzYuanBn" alt="TCP 头格式" style="zoom: 50%;"><p><strong>序列号</strong>：在建立连接时，由计算机生成的随机数作为初始值，通过SYN包传送给接收端主机，没发送一次数据，就会“累加”一次该”数据字节数”的大小。主要用来解决网络包乱序的问题。</p><p><strong>确认应答号</strong>：指下一次*”期望”<em>收到数据的序列号，发送端收到这个确认应答之后就可以认为在这个序列号以前的数据都已经被正常的接受。主要用来解决</em>丢包*问题。</p><p><strong>控制位</strong>：</p><ul><li><em>ACK</em>：该位为 <code>1</code> 时，确认应答 的字段变为有效，TCP 规定<em><strong>除了</strong>最初建立连接时的 <code>SYN</code> 包之外（第一次握手）</em>该位必须设置为 <code>1</code> 。</li><li><em>RST</em>：该位为 <code>1</code> 时，表示 TCP 连接中<strong>出现异常</strong>必须<strong>强制断开连接</strong>。</li><li><em>SYN</em>：该位为 <code>1</code> 时，表示希望建立连接，并在其 序列号 的字段进行序列号初始值的设定。</li><li><em>FIN</em>：该位为 <code>1</code> 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 <code>FIN</code> 位为 1 的 TCP 段。</li></ul><h2 id="为什么需要TCP协议？"><a href="#为什么需要TCP协议？" class="headerlink" title="为什么需要TCP协议？"></a>为什么需要TCP协议？</h2><p>IP 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。</p><p>如果需要保障网络数据包的可靠性，那么就需要由上层（传输层）的 <code>TCP</code> 协议来负责。</p><p>因为 TCP 是一个工作在<strong>传输层</strong>的<strong>可靠</strong>数据传输的服务，它能确保接收端接收的网络包是  无损坏、无间隔、非冗余和按序的。</p><h2 id="什么是TCP协议？"><a href="#什么是TCP协议？" class="headerlink" title="什么是TCP协议？"></a>什么是TCP协议？</h2><p>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。</p><p>面向连接：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</p><p><a href="#TCP%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E5%8F%AF%E9%9D%A0%E6%80%A7%EF%BC%9F">可靠性</a>：无论的<strong>网络链路中</strong>出现了怎样的链路变化，TCP都可以<strong>保证一个报文一定能够到达接收端</strong>；</p><p>字节流：用户消息通过 TCP 协议传输时，<strong>消息可能会被操作系统「分组」成多个的 TCP 报文</strong>，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。</p><h2 id="TCP如何做到可靠性？"><a href="#TCP如何做到可靠性？" class="headerlink" title="TCP如何做到可靠性？"></a>TCP如何做到可靠性？</h2><p><strong>粗略</strong>：</p><p>因为TCP在<strong>数据传输之前会有三次握手</strong>来进行连接<br>在数据传输时候，有确认、滑动窗口、超时重传、拥塞控制之类机制<br>数据传输之后会进行四次挥手断开连接来节约系统资源。</p><p><strong>具体：</strong></p><p>1、应用数据被分割成TCP认为最适合发送的数据块<br>2、TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。<br>3、校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。<br>4、TCP 的接收端会丢弃重复的数据。<br>5、利用滑动窗口实现流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）<br>6、拥塞控制： 当网络拥塞时，减少数据的发送。<br>7、ARQ协议： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。<br>8、超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络 小林Coding</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
